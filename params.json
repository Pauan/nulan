{"tagline":"A fast Lisp with customizable syntax, pattern matching, hygienic macros, and hyper-static scope","note":"Don't delete this file! It's used internally to help with page regeneration.","body":"How to install\r\n==============\r\n\r\n```\r\ngit clone --recursive https://github.com/Pauan/nulan.git nulan\r\n```\r\n\r\nHow to run\r\n==========\r\n\r\nBrowser\r\n-------\r\n\r\nLoad ``nulan.html`` in a modern web browser (I've only tested with Google Chrome 23)\r\n\r\n\r\nNode.js\r\n-------\r\n\r\nUse ``./nulan`` to get to a REPL (I've only tested with version 0.8.5)\r\n\r\n\r\nFeatures\r\n========\r\n\r\n* A full-blown Lisp, which means programs are parsed as S-expressions, and there's a very heavy emphasis on \"code is data is code\"\r\n\r\n* [Pattern matching](nulan/blob/javascript/notes/Pattern%20matching.rst)\r\n\r\n* `Hyper-static scope <nulan/blob/javascript/notes/Hyper-static%20scope.rst>`_ at both the global and function level\r\n\r\n* `Hygienic macros <nulan/blob/javascript/notes/Hygienic%20macros.rst>`_ which are even easier to use than Arc/Common Lisp macros\r\n\r\n* `Customizable syntax <nulan/blob/javascript/notes/Customizable%20syntax.rst>`_ to make common idioms shorter and easier to read\r\n\r\n* The compiler is written in JavaScript and is capable of running in a browser: you can incrementally compile/eval Nulan programs at runtime\r\n\r\n* Compiles ahead-of-time to extremely fast JavaScript: it should be just as fast or faster than handwritten JS code\r\n\r\n* Includes an awesome IDE (built using `CodeMirror <http://codemirror.net/>`_) that runs right in the browser: just open ``nulan.html``\r\n\r\n\r\nExamples\r\n========\r\n\r\n::\r\n\r\n  # This is a dictionary\r\n  box foo = [ bar 5 qux 10 ]\r\n\r\n  # Key lookup\r\n  foo.bar\r\n  foo.qux\r\n\r\n  # Key assignment\r\n  foo.bar <= 20\r\n  foo.qux <= 30\r\n\r\n  # This is a function\r\n  def set -> a\r\n    | box x = foo[a]  # Lookup by expression\r\n    | foo[a] <= 50    # Assign by expression\r\n    | x\r\n\r\n  set \"bar\"\r\n  set \"qux\"\r\n\r\n  foo.bar\r\n  foo.qux\r\n\r\n::\r\n\r\n  # Simulating a `for` loop using a `while` loop\r\n  $mac for -> init test incr body\r\n    'w/new-scope\r\n       | init\r\n       | while test\r\n           | body\r\n           | incr\r\n\r\n  for (box i = 0) (i < 10) (++ i)\r\n    prn i\r\n\r\n::\r\n\r\n  # Simulating a `do..while` loop using a `while` loop\r\n  $mac do -> body {('while) test}\r\n    'while %t\r\n       | body\r\n       | if ~ test\r\n           &break;\r\n\r\n  box i = 0\r\n  do\r\n    | prn i\r\n    | ++ i\r\n    while (i < 10)\r\n\r\n::\r\n\r\n  # Infinite loop; be careful, the only way to stop it is to shut down the terminal!\r\n  $mac 5ever -> body\r\n    'while %t\r\n       body\r\n\r\n  5ever\r\n    | prn 1\r\n    | prn 2\r\n    | prn 3\r\n    | prn 4\r\n    | prn \"das mor den 4ever\"\r\n\r\n::\r\n\r\n  # Macro to iterate over the elements of any list or string\r\n  $mac w/each -> {('=) x y} body\r\n    w/uniq i len\r\n      w/complex y\r\n        'w/box len = y.length\r\n           for (box i = 0) (i ~= len) (++ i)\r\n             w/box x = y[i]\r\n               body\r\n\r\n  w/each x = {1 2 3}\r\n    | prn x\r\n    | prn x + 5\r\n    | prn;\r\n\r\n::\r\n\r\n  # Macro to iterate over the elements of any list or string in reverse order\r\n  $mac w/each-rev -> {('=) x y} body\r\n    w/uniq i\r\n      w/complex y\r\n        'w/box i = y.length\r\n           while i\r\n             w/box x = y[-- i]\r\n               body\r\n\r\n  w/each-rev x = {1 2 3}\r\n    | prn x\r\n    | prn x + 5\r\n    | prn;\r\n\r\n::\r\n\r\n  # The built-in Array methods work very nicely with Nulan's -> syntax\r\n  {1 2 3}.for-each -> x\r\n    | prn x\r\n    | prn x + 5\r\n    | prn;\r\n\r\n  {1 2 3}.map -> x\r\n    x + 5\r\n\r\n  {1 2 3}.reduce -> x y\r\n    \"(@x @y)\"\r\n\r\n::\r\n\r\n  # An example of an unhygienic macro\r\n  # Just like in Arc, it binds the symbol `it` to the test condition\r\n  $mac aif -> test @rest\r\n    w/box it = sym \"it\"\r\n      'w/box it = test\r\n         if it ,@:if rest.length >= 2\r\n                    w/box {x @rest} = rest\r\n                      'x (aif ,@rest)\r\n                    rest\r\n\r\n  aif 1 + 2\r\n    it\r\n    it\r\n\r\n  aif %f\r\n    it\r\n    it\r\n\r\n::\r\n\r\n  def foo -> x y\r\n    x + y\r\n\r\n  $syntax-infix foo\r\n\r\n  1 foo 2    # Custom infix syntax\r\n\r\n  (foo) 1 2  # Wrapping in parens disables syntax\r\n\r\n::\r\n\r\n  # Array comprehensions\r\n  box in\r\n\r\n  $mac for -> x {('in) n y}\r\n    'y.map -> n x\r\n\r\n  $syntax-infix for 0 [ order \"right\" ]\r\n  $syntax-infix in  0 [ order \"right\" ]\r\n\r\n  (x + 2) for x in {1 2 3}\r\n\r\n::\r\n\r\n  #! /usr/bin/env nulan\r\n\r\n  # A shell script that creates a simple HTTP server\r\n  # Taken from http://nodejs.org/\r\n  box net = require \"net\"\r\n\r\n  box server = net.create-server -> o\r\n                 | o.write \"Echo server\\r\\n\"\r\n                 | o.pipe o\r\n\r\n  server.listen 1337 \"127.0.0.1\"\r\n\r\n\r\nFAQ\r\n===\r\n\r\n* **Q:** Why doesn't this work?!\r\n\r\n  ::\r\n\r\n    def foo -> x\r\n      bar x + 1\r\n\r\n    def bar -> x\r\n      x + 5\r\n\r\n    foo 20\r\n\r\n  **A:** Nulan uses hyper-static scope, so you need to rearrange it so ``foo`` is defined after ``bar``::\r\n\r\n    def bar -> x\r\n      x + 5\r\n\r\n    def foo -> x\r\n      bar x + 1\r\n\r\n    foo 20\r\n\r\n* **Q:** Well, okay, but what about this?\r\n\r\n  ::\r\n\r\n    $mac foo ->\r\n      '1 + 2\r\n\r\n    prn foo\r\n\r\n  **A:** Nulan has a *very* strict separation between compile-time and run-time: things that exist at compile-time **cannot** be used at run-time in any way, shape, or form. And vice versa: things that exist at run-time cannot be used at compile-time.\r\n\r\n  Certain macros like ``$mac`` are prefixed with ``$`` which indicates that they are evaluated at compile-time. To make the above example work, you have to evaluate the expression at compile-time by using ``$run``::\r\n\r\n    $mac foo ->\r\n      '1 + 2\r\n\r\n    $run\r\n      prn foo\r\n\r\n* **Q:** If there's such a strict separation between the two, why does this work?\r\n\r\n  ::\r\n\r\n    def foo -> x\r\n      x + 1\r\n\r\n    $mac bar -> x\r\n      'foo x\r\n\r\n    bar 10\r\n\r\n  **A:** Nulan replaces symbols with boxes. The *value* of the symbol ``foo`` is not available, but the *box* is.\r\n\r\n  The ``'`` macro returns boxes, which means that the ``bar`` macro returns the *box* for ``foo``, not the *value* for ``foo``. This is the **only** way that you can use run-time stuff at compile-time.\r\n\r\n  However, this would not work...\r\n\r\n  ::\r\n\r\n    $mac bar -> x\r\n      foo x\r\n\r\n  ...because it's trying to use the *value* of the ``foo`` symbol, which doesn't exist at compile-time.\r\n\r\n  In addition, if a *macro* is the first element of a list, it is evaluated at compile-time, which is why ``bar 10`` works. But ``prn bar 10`` would **not** work, because the macro ``bar`` isn't the first element of the list\r\n\r\n* **Q:**\r\n","name":"Nulan","google":""}