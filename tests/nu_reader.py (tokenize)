##############################################################################
#  tokenize1 errors
##############################################################################
>>> write(r'"foo bar')
error: missing ending " quote
  "foo bar  (line 1, column 8)
         ^

>>> write(r'"foo\uABCGbar"')
error: G is not valid hexadecimal
  "foo\uABCG  (line 1, column 10)
           ^

>>> write(r'"foo\hbar"')
error: unknown escape sequence h
  "foo\h  (line 1, column 6)
       ^

>>> write(r'#|foo bar')
error: missing ending |# block
  #|foo bar  (line 1, column 9)
          ^

>>> write(r'==')
error: == is invalid (you probably meant to use =)
  ==  (line 1, column 2)
   ^

>>> write(r'>=')
error: >= is invalid (you probably meant to use =>)
  >=  (line 1, column 2)
   ^

>>> write(r',')
error: invalid character ,
  ,  (line 1, column 1)
  ^

>>> write('5 ')
error: useless whitespace
  5   (line 1, column 2)
   ^

>>> write(' \n5 ')
error: useless whitespace
     (line 1, column 1)
  ^

>>> write('\n\n5 ')
error: useless whitespace
  5   (line 3, column 2)
   ^

>>> write('\n \n5 ')
error: useless whitespace
     (line 2, column 1)
  ^

>>> write('5 \n10')
error: useless whitespace
  5   (line 1, column 2)
   ^

##############################################################################
#  tokenize errors
##############################################################################
>>> write("(foo]")
error: mismatched parentheses
  (foo]  (line 1, column 5)
      ^

>>> write("foo]")
error: missing starting [ parenthesis
  foo]  (line 1, column 4)
     ^

>>> write("(foo")
error: missing ending ) parenthesis
  (foo  (line 1, column 4)
     ^

>>> tokenize("1 + 2", indent=False)
error: + must occur inside parentheses
  1 +  (line 1, column 3)
    ^

>>> write("1 +")
error: expected an expression after +
  1 +  (line 1, column 3)
    ^

>>> write("(1 +)")
error: expected an expression after +
  (1 +)  (line 1, column 5)
      ^

##############################################################################
#  tokenize1
##############################################################################
>>> write(r'''
... foo [
...   bar]
... ''')
[(&symbol foo) [(&fn seq) (&symbol bar)]]

>>> tokenize(r'''
... [$on-error X
...   [fn [seq: error ~] Y]
...   @(joinr R [$fn [seq U] U])]
... ''')
indentation
[
$on-error
X
[
fn
[
seq
[
error
(&fn %tilde)
]
]
Y
]
@
(
joinr
R
[
$fn
[
seq
U
]
U
]
)
]
deindentation
Token: EOFToken


>>> write(r'''
... "foo
...  bar
...  qux"
... ''')
u

##############################################################################
#  tokenize one
##############################################################################
>>> tokenize("1 2 3 4", indent=False, one=True)
1
Token: EOFToken

>>> tokenize("(1 2 3 4)", indent=False, one=True)
(
1
2
3
4
)
Token: EOFToken

>>> tokenize("(1 (2 3) 4)", indent=False, one=True)
(
1
(
2
3
)
4
)
Token: EOFToken

>>> tokenize("1 + 2 3 4", indent=False, one=True)
1
Token: EOFToken

>>> write("(foo; bar; qux")
error: can't use ; after ;
  (foo; bar;  (line 1, column 10)
           ^

>>> write("(foo; bar: qux")
error: can't use : after ;
  (foo; bar:  (line 1, column 10)
           ^

##############################################################################
#  : and ; syntaxes
##############################################################################
>>> write("(foo: bar; qux; corge; nou)")
[(&symbol foo) [(&symbol bar)] [(&symbol qux)] [(&symbol corge)] [(&symbol nou)]]

>>> write("(foo: bar: qux; corge; nou)")
[(&symbol foo) [(&symbol bar) [(&symbol qux)] [(&symbol corge)] [(&symbol nou)]]]

>>> write("(foo: bar: qux: corge; nou)")
[(&symbol foo) [(&symbol bar) [(&symbol qux) [(&symbol corge)] [(&symbol nou)]]]]

>>> write("(foo: bar: qux: corge: nou)")
[(&symbol foo) [(&symbol bar) [(&symbol qux) [(&symbol corge) [(&symbol nou)]]]]]

>>> write("(foo: bar; qux: corge: nou)")
[(&symbol foo) [(&symbol bar)] [(&symbol qux) [(&symbol corge) [(&symbol nou)]]]]

>>> write("(foo: bar; qux; corge: nou)")
[(&symbol foo) [(&symbol bar)] [(&symbol qux)] [(&symbol corge) [(&symbol nou)]]]

>>> write("(foo: bar; qux: corge; nou)")
[(&symbol foo) [(&symbol bar)] [(&symbol qux) [(&symbol corge)] [(&symbol nou)]]]

>>> write("(foo: bar: qux; corge: nou)")
[(&symbol foo) [(&symbol bar) [(&symbol qux)] [(&symbol corge) [(&symbol nou)]]]]

>>> write("(foo; bar (qux corge) nou)")
[(&symbol foo) [(&symbol bar) [(&symbol qux) (&symbol corge)] (&symbol nou)]]


>>> write("(foo: bar [qux] corge (nou) yes)")
[(&symbol foo) [(&symbol bar) [(&fn seq) (&symbol qux)] (&symbol corge)] [(&symbol nou)] (&symbol yes)]

##############################################################################
#  ->
##############################################################################
>>> tokenize("foo bar -> qux corge")
indentation
foo
bar
->
indentation
qux
corge
deindentation
deindentation
Token: EOFToken

>>> tokenize("foo: bar -> qux corge")
indentation
foo
(
bar
->
indentation
qux
corge
deindentation
)
deindentation
Token: EOFToken

>>> tokenize("foo: bar -> qux; corge")
indentation
foo
(
bar
->
indentation
qux
deindentation
(
corge
)
)
deindentation
Token: EOFToken

>>> tokenize("foo bar -> qux; corge; nou")
indentation
foo
bar
->
indentation
qux
deindentation
(
corge
)
(
nou
)
deindentation
Token: EOFToken

>>> tokenize(r'''
... $def prn!; @Args ->
...   pr! @Args
...   pr! "\n"
... ''')
indentation
$def
prn!
(
@
Args
->
indentation
pr!
@
Args
deindentation
indentation
pr!
[(&fn str) \n]
deindentation
)
deindentation
Token: EOFToken

>>> tokenize(r'''
... $defvau $and
...   X    -> eval X
...   X @R -> $if: eval X
...             eval [$and @R]
... ''')
indentation
$defvau
$and
indentation
X
->
indentation
eval
X
deindentation
deindentation
indentation
X
@
R
->
indentation
$if
(
eval
X
)
indentation
eval
[
$and
@
R
]
deindentation
deindentation
deindentation
deindentation
Token: EOFToken

##############################################################################
#  nu.nu
##############################################################################
>>> for x in read_file("nu.nu"): print x.pretty()
($assign $let ($vau Env [X Y @ R] (eval Env [[$fn [seq X] @ R] Y])))
($assign $quote ($vau (&fn %tilde) [X] X))
($assign $or ($vau Env [X @ R] ($let X (eval Env X) ($if X X (eval Env [$or @ R])))))
($assign any? ($fn [[X @ R] F] ($or (F X) (any? R F))))
($assign case ($fn [X @ Fns] (any? Fns ($fn [F] (F @ X)))))
($assign case-vau ($vau Env Fns ($let Args (uniq) (eval Env [$vau ($quote %Env) Args [case Args @ Fns]]))))
($assign case-fn ($fn [@ Fns] ($fn [@ Args] (case Args @ Fns))))
($assign $defvau ($vau Env [Name @ Fns] (eval Env [$assign Name [case-vau @ Fns]])))
($assign $def ($vau Env [Name @ Fns] (eval Env [$assign Name [case-fn @ Fns]])))
($def get-current-env (wrap ($vau Env [] Env)))
($def make-env ($fn [Env] (eval Env [[$vau (&fn %tilde) (&fn %tilde) [get-current-env]]])))
($def make-base-env ($let Top (get-current-env) ($fn [] (make-env Top))))
($def $use ($vau Env Args (each Args ($fn [X] ($let New (make-base-env) ($hook Env get-if-unbound ($fn [K] (eval New K))) (load-file-in New (find-file X)) (eval Env [$def (strip-extension (basename X)) New]))))))
($def eachf ($fn [[X @ R] F] (F X) (each R F)) ($fn [(&fn %tilde) (&fn %tilde)] %f))
($def not ($fn [X] ($if X %f %t)))
($defvau do ($fn [@ Args] (eval [[$fn [] @ Args]])))
($defvau $and ($fn [X] (eval X)) ($fn [X @ R] ($if (eval X) (eval [$and @ R]))))
($def all? ($fn [[X] F] (F X)) ($fn [[X @ R] F] ($and (F X) (all? R F))))
($def none? ($fn [X F] (all? X ($fn [X] (not (F X))))))
($def fn-fn ($fn [F] ($fn [@ Fns] ($fn [@ Args] (F Fns ($fn [X] (X @ Args)))))))
($def fn-not (fn-fn none?))
($def fn-and (fn-fn all?))
($def fn-or (fn-fn any?))
($def sum ($fn [[X @ R] F] (sum1 X R F)) ($fn [I X F] (sum1 I X F)))
($def sum1 ($fn [I [X @ R] F] (sum1 (F I X) R F)) ($fn [I (&fn %tilde) (&fn %tilde)] I))
($def sumr ($fn [[X @ R] F] (F X (sumr R F))) ($fn [X (&fn %tilde)] X) ($fn [X I F] (sumr1 X I F)))
($def sumr1 ($fn [[X @ R] I F] (F X (sumr R I F))) ($fn [(&fn %tilde) I (&fn %tilde)] I))
($def compose ($fn [@ Fns] (sum Fns ($fn [X Y] ($fn [@ Args] (X (Y @ Args)))))))
($def each ($fn [X F] (sumr X [] ($fn [X Y] [(F X) @ Y]))))
($def rev ($fn [X] (sum [] X ($fn [Y X] [X @ Y]))))
($def keep ($fn [X F] (sumr X [] ($fn [X Y] ($if (F X) [X @ Y] Y)))))
($def rem ($fn [X F] (keep X (fn-not F))))
($def empty? ($fn [[]] %t))
($def first ($fn [[X @ (&fn %tilde)]] X))
($def rest ($fn [[(&fn %tilde) @ R]] R))
($def zip ($fn [@ Args] ($if (any? Args empty?) [] [(each Args first) @ (zip @ (each Args rest))])))
($def join ($fn [[X @ R] Y] [X @ (join R Y)]) ($fn [[X] Y] [X @ Y]))
($def joinr ($fn [X Y] (join X [Y])))
($def ref ($fn [[K V @ R] K] V) ($fn [[(&fn %tilde) (&fn %tilde) @ R] K] (ref R K)))
($def iso? ($fn [X X] %t) ($fn [[X @ R1] [Y @ R2]] ($and (iso? X Y) (iso? R1 R2))))
($def prn! ($fn [@ Args] (pr! @ Args) (pr! "\n")))
($def writen! ($fn [@ Args] (write! @ Args) (pr! "\n")))
($defvau $lets ($fn [[X]] (eval X)) ($fn [[[X Y] @ R]] (eval [$let X Y [$lets @ R]])))
($defvau $if-error ($fn [[X Y @ R]] ($let U (uniq) (eval [$on-error X [$fn [seq [error (&fn %tilde)]] Y] @ (joinr R [$fn [seq U] U])]))))
($defvau $def-if! ($fn [Name Test @ Fns] ($lets (Orig (eval Name)) (Test (eval Test)) (F ($fn Args ($if-error (Test @ Args) (Orig @ Args)))) (eval [$assign! Name [case-fn F @ Fns]]))))
