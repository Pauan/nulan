(PROTOCOL ($and a)
  and :: (-> a a a))

(PROTOCOL ($or a)
  or :: (-> a a a))

(PROTOCOL ($not a)
  not :: (-> a a))


(TYPE Boolean
  *false
  *true)

(REWRITE-RULE
  (IF ~test ~then ~else)
    &(MATCH ~test
       *true
         ~then
       *false
         ~else))

(REWRITE-RULE
  (AND ~a ~b)
    &(IF ~a
       ~b
       *false)
  (AND ~a ~@b)
    &(AND ~a (AND ~@b)))

(REWRITE-RULE
  (OR ~a ~b)
    &(IF ~a
       *true
       ~b)
  (OR ~a ~@b)
    &(OR ~a (OR ~@b)))


(FUNCTION and :: (-> Boolean Boolean Boolean)
  (and a b)
    (AND a b))

(FUNCTION or :: (-> Boolean Boolean Boolean)
  (or a b)
    (OR a b))

(FUNCTION not :: (-> Boolean Boolean)
  (not *true)
    *false
  (not *false)
    *true)


# TODO maybe replace with an equal? function ?
(REWRITE-RULE
  (IS? ~a ~b)
    &(MATCH ~a
       ~b
         *true
       _
         *false))

(REWRITE-RULE
  (TRANSFORM-AND ~a ~b)
    &(transform2 ~a ~b and)
  (TRANSFORM-AND ~a ~b ~@c)
    # TODO should this lean left or right ?
    &(TRANSFORM-AND (TRANSFORM-AND ~a ~b) ~@c))

(REWRITE-RULE
  (TRANSFORM-OR ~a ~b)
    &(transform2 ~a ~b or)
  (TRANSFORM-OR ~a ~b ~@c)
    # TODO should this lean left or right ?
    &(TRANSFORM-OR (TRANSFORM-OR ~a ~b) ~@c))

# Added for consistency with TRANSFORM-AND and TRANSFORM-OR
(REWRITE-RULE
  (TRANSFORM-NOT ~a)
    &(transform ~a not))


(EXPORT-CONSTANT
  true <= *true
  false <= *false)

(EXPORT
  Boolean
  not
  and
  or
  IF
  AND
  OR
  IS?
  TRANSFORM-AND
  TRANSFORM-OR
  TRANSFORM-NOT)
