(IMPORT (file "protocol.nul")
  | $transform
  | $flatten
  | _transform = transform
  | _flatten = flatten)

(DEFINE-GROUP (Task a))

(UNSAFE-FFI-IMPORT (file "../ffi/task.js")
  transform     :: (-> (Task a) (-> a b) (Task b))
  flatten       :: (-> (Task (Task a)) (Task a))
  after         :: (-> (Task a) (-> a (Task b)) (Task b))
  wrap          :: (-> a (Task a))
  sequential    :: (-> (List (Task a)) (Task (List a)))
  concurrent    :: (-> (List (Task a)) (Task (List a)))
  fastest       :: (-> (List (Task a)) (Task a))
  perform       :: (-> (Task Null) Null)
  delay         :: (-> Integer (Task Null))
  throw_error   :: (-> Error (Task a))
  on_error      :: (-> (Task a) (-> Error (Task a)) (Task a))
  ignore_kill   :: (-> (Task a) (Task a))
  unkillable    :: (-> (Task a) (Task a))
  with_resource :: (-> (Task a)
                       (-> a (Task b))
                       (-> a (Task Null))
                       (Task b)))

(IMPLEMENT ($transform Task)
  (_transform a fn)
    (transform a fn))

(IMPLEMENT ($flatten Task)
  (_flatten a)
    (flatten a))

(DEFINE-ALIAS
  (WITH-RESOURCE &(~n = ~v) use close)
    &(with_resource ~v
       (-> ~n ~use)
       (-> ~n ~close)))

(DEFINE timeout :: (-> (Task a) Integer (Task (Maybe a)))
  (timeout task ms)
    (fastest
      [(transform task *some)
       (transform (delay ms) -> _ *none)]))


# TODO put into other module
(DEFINE after :: (REQUIRE ($transform a) ($flatten a)
                   (-> (a b) (-> b (a c)) (a c)))
  (after a fn)
    (flatten (transform a fn)))

# TODO this should work for all monads
(DEFINE-ALIAS
  (DO a)
    a
  (DO &(~pattern = ~value) @a)
    &(after ~value -> ~pattern
       (DO ~@a))
  (DO value @a)
    &(after ~value -> *null
       (DO ~@a)))

(DEFINE-GROUP (Result a)
  (*value a)
  (*error Error))

(DEFINE result :: (-> (Task a) (Task (Result a)))
  (result a)
    (on_error a *value *error))


(EXPORT
  | Task
  | Result
  | *value
  | *error
  | ($transform Task)
  | ($flatten Task)
  | ($wrap Task)
  | sequential
  | concurrent
  | fastest
  | timeout
  | after
  | DO
  | throw-error = throw_error
  | result
  | ignore-kill = ignore_kill
  | unkillable)



(WITH-RESOURCE fd = (open-file "foo")
  (read fd)
  (close-file fd))

(DO fd = (open-file "foo")
    (finally
      (read fd)
      (close-file fd)))

a = (Task a)
b = (Task b)
c = (Task Null)

Cancel a -> Run c
Error a -> Error a
Success a -> Run b

Cancel b -> Run c
Error b -> Run c -> Error b
Success b -> Run c -> Success b

Cancel c ->
Error c -> Error c
Success c -> Success b
