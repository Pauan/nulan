(TYPE (Stream a)
| (*stream (-> b (-> b a (Task b)) (Task b))))


(UNSAFE-FFI-LOAD { target <= javascript
                 | file "../ffi/stream.js" }
| transform-pair :: (-> (Stream a) (Stream b) (Stream (Pair a b))))


(FUNCTION accumulate :: (-> a (Stream b) (-> a b a) (Stream a))
| (accumulate init (*stream each) f)
    (*stream -> init push
      (each init -> a b
        (push a (f a b)))))

# TODO should this inline ?
(FUNCTION reduce-left :: (INLINE (-> a (Stream b) (-> a b (Task a)) (Task a)))
| (reduce-left init (*stream each) f)
    (each init -> a b
      (f a b)))

# TODO should this inline ?
(FUNCTION each :: (INLINE (-> (Stream a) (-> a (Task Null)) (Task Null)))
| (each a f)
    (reduce-left null a -> _ a
      (f a)))

(FUNCTION transform-maybe :: (-> (Stream a) (-> a (Maybe b)) (Stream b))
| (transform-maybe (*stream each) f)
    (*stream -> init push
      (each init -> a b
        (MATCH (f b)
        | *none
            (yield a)
        | (*some b)
            (push a b)))))

(FUNCTION transform :: (INLINE (-> (Stream a) (-> a b) (Stream b)))
| (transform a f)
    (transform-maybe a -> a
      (*some (f a))))

(FUNCTION concat :: (-> (Stream a) (Stream a) (Stream a))
| (concat (*stream each1) (*stream each2))
    (*stream init1 -> push
      (DO init2 <= (each1 init1 push)
          (each2 init2 push))))

(FUNCTION flatten :: (-> (Stream (Stream a)) (Stream a))
| (flatten (*stream each))
    (*stream -> init push
      (each init -> a (*stream each)
        (each a push))))

(FUNCTION yield :: (-> a (Stream a))
| (yield a)
    (*stream -> init push
      (push init a)))

# TODO should this inline ?
(FUNCTION list<- :: (INLINE (-> (Stream a) (Task (List a))))
| (list<- a)
    (reduce-left [] a -> list a
      (yield (unsafe-push! list a))))

# TODO should this inline ?
(FUNCTION size :: (INLINE (-> (Stream a) (Task Integer)))
| (size a)
    (reduce-left 0 a -> sum _
      (yield (+ sum 1))))

# TODO is this correct ?
(FUNCTION stream<- :: (REQUIRE ($iterator<- a)
                        (-> (a b) (Stream b)))
| (stream<- a)
    (*stream -> init push
      (reduce-left init a push)))


(FUNCTION time-more? :: (-> Integer (Maybe Integer) Boolean)
| (time-more? _ *none)
    true
| (time-more? a (*some b))
    (more? a b))

# TODO is this useful ?
(FUNCTION throttle :: (-> (Stream a) Integer (Stream a))
| (throttle stream delay)
    (*stream -> state push
      (LET result <= (reduce-left { state
                                  | waiting <= *none } stream -> { state waiting } value
                       (DO now <= current-time
                           (IF (time-more? now waiting)
                           | (DO state <= (push state value)
                                 (yield { state
                                        | waiting <= (*some (+ now delay)) }))
                           | (yield { state waiting }))))
      | (DO { state waiting } <= result
            (yield state)))))




(TYPE (Stream a)
  (*stream (-> b (-> b a (Task b)) (Task b))))

(TYPE (Stream a)
  (*stream (-> (Output a) (Task Null))))


(FUNCTION make-stream :: (-> (-> (Output a) (Task Null)) (Stream a)))

(FUNCTION with-stream :: (-> (Stream a) (-> (Input a) (Task Null)) (Task Null)))

(FUNCTION pull :: (-> (Input a) (Task a)))

(FUNCTION push :: (-> (Output a) a (Task Null)))


(FUNCTION make-stream :: (-> (-> (-> a (Task Null)) (Task Null)) (Stream a)))

(FUNCTION with-stream :: (-> (Stream a) (-> (Task a) (Task Null)) (Task Null)))

(FUNCTION with-stream :: (-> (Stream a) (Task (Task a))))


(TYPE (Stream a)
  (*stream (Task (Task a))))

(FUNCTION make-stream :: (-> (Task (Task a)) (Stream a))
  (make-stream a)
    (*stream a))

(FUNCTION with-stream :: (-> (Stream a) (Task (Task a)))
  (with-stream (*stream a))
    a)


(make-stream
  (DO pull <= (with-stream a)
      (wrap (transform pull -> value
              (MATCH value
                *done
                  *done

                *skip
                  *skip

                (*value value)
                  (*value (f value)))))))


(TYPE (Stream a)
  (*stream (-> (-> a (Task Null)) (Task Null))))

(FUNCTION with-stream :: (-> (Stream a) (-> (Task a) (Task Null)) (Task Null))
  (with-stream (*stream each) f)
    (each -> value
      (f (wrap value))))


# TODO test this
# TODO can this be implemented more efficiently ?
(FUNCTION queue :: (-> Integer (Stream a) (Stream a))
  (queue max stream)
    (make-stream -> push
      (DO pull <= (with-stream stream)
          (LOOP queue <= empty :: (Queue a)
            (LET l <= (length queue)
              (IF (equal? l 0)
                (DO value <= pull
                    (loop (push queue value)))

                (IF (equal? l max)
                  (DO (push (peek queue))
                      (loop (pop queue)))

                  (flatten
                    (fastest
                      (transform pull -> value
                        (loop (push queue value)))
                      (transform (push (peek queue)) -> _
                        (loop (pop queue))))))))))))


(make-stream -> push
  (with-stream a -> pull
    (forever
      (DO value <= pull
          (push (f value))))))

(make-stream -> push
  (DO pull <= (with-stream a)
      (forever
        (DO value <= pull
            (push (f value))))))



(FUNCTION reduce-left :: (-> a (Stream b) (-> a b (Task a)) (Task a))
  (reduce-left a s f)
    (with-stream s -> pull
      (LOOP init <= a
        (DO value <= pull
            init <= (f init value)
            (next init)))))

(FUNCTION reduce-left :: (-> a (Stream b) (-> a b (Task a)) (Task a))
  (reduce-left a (*stream fold) f)
    (fold a f))

(FUNCTION each :: (-> (Stream a) (-> a (Task Null)) (Task Null))
  (each stream f)
    (reduce-left *null stream -> _ new
      (f new)))

(FUNCTION transform-maybe :: (-> (Stream a) (-> a (Maybe b)) (Stream b))
  (transform-maybe (*stream fold) f)
    (*stream -> initial step
      (fold initial -> old new
        (MATCH (f new)
          (*some a)
            (step old a)
          *none
            (wrap old)))))

(FUNCTION transform :: (-> (Stream a) (-> a b) (Stream b))
  (transform a b)
    (transform-maybe a -> c
      (*some (b c))))

(FUNCTION concat :: (-> (Stream a) (Stream a) (Stream a))
  (concat (*stream fold1) (*stream fold2))
    (*stream -> initial step
      (DO a <= (fold1 initial step)
          b <= (fold2 a step)
          b)))

(FUNCTION wrap :: (-> a (Stream a))
  (wrap a)
    (*stream -> initial step
      (step initial a)))

(FUNCTION flatten :: (-> (Stream (Stream a)) (Stream a))
  (flatten (*stream fold))
    (*stream -> initial step
      (fold initial -> old (*stream fold)
        (fold old step))))

# TODO maybe use a protocol for this ?
(FUNCTION from-list :: (-> (List a) (Stream a))
  (from-list a)
    (*stream -> initial step
      (reduce-left initial a step)))
