<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>Nulan by Pauan</title>

    <link rel="stylesheet" href="stylesheets/styles.css">
    <link rel="stylesheet" href="stylesheets/pygment_trac.css">
    <script src="javascripts/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
  </head>
  <body>
    <div class="wrapper">
      <header>
        <h1 class="header">Nulan</h1>
        <p class="header">A fast Lisp with customizable syntax, pattern matching, hygienic macros, and hyper-static scope</p>

        <ul>
          <li class="download"><a class="buttons" href="https://github.com/Pauan/nulan/zipball/master">Download ZIP</a></li>
          <li class="download"><a class="buttons" href="https://github.com/Pauan/nulan/tarball/master">Download TAR</a></li>
          <li><a class="buttons github" href="https://github.com/Pauan/nulan">View On GitHub</a></li>
        </ul>

        <p class="header">This project is maintained by <a class="header name" href="https://github.com/Pauan">Pauan</a></p>


      </header>
      <section>
        <h1>How to install</h1>

<pre><code>git clone --recursive https://github.com/Pauan/nulan.git nulan
</code></pre>

<h1>How to run</h1>

<h2>Browser</h2>

<p>Load <code>nulan.html</code> in a modern web browser (I've only tested with Google Chrome 23)</p>

<h2>Node.js</h2>

<p>Use <code>./nulan</code> to get to a REPL (I've only tested with version 0.8.5)</p>

<h1>Features</h1>

<ul>
<li><p>A full-blown Lisp, which means programs are parsed as S-expressions, and there's a very heavy emphasis on "code is data is code"</p></li>
<li><p><a href="nulan/blob/javascript/notes/Pattern%20matching.rst">Pattern matching</a></p></li>
<li><p><code>Hyper-static scope &lt;nulan/blob/javascript/notes/Hyper-static%20scope.rst&gt;</code>_ at both the global and function level</p></li>
<li><p><code>Hygienic macros &lt;nulan/blob/javascript/notes/Hygienic%20macros.rst&gt;</code>_ which are even easier to use than Arc/Common Lisp macros</p></li>
<li><p><code>Customizable syntax &lt;nulan/blob/javascript/notes/Customizable%20syntax.rst&gt;</code>_ to make common idioms shorter and easier to read</p></li>
<li><p>The compiler is written in JavaScript and is capable of running in a browser: you can incrementally compile/eval Nulan programs at runtime</p></li>
<li><p>Compiles ahead-of-time to extremely fast JavaScript: it should be just as fast or faster than handwritten JS code</p></li>
<li><p>Includes an awesome IDE (built using <code>CodeMirror &lt;http://codemirror.net/&gt;</code>_) that runs right in the browser: just open <code>nulan.html</code></p></li>
</ul><h1>Examples</h1>

<p>::</p>

<p># This is a dictionary
  box foo = [ bar 5 qux 10 ]</p>

<p># Key lookup
  foo.bar
  foo.qux</p>

<p># Key assignment
  foo.bar &lt;= 20
  foo.qux &lt;= 30</p>

<p># This is a function
  def set -&gt; a
    | box x = foo[a]  # Lookup by expression
    | foo[a] &lt;= 50    # Assign by expression
    | x</p>

<p>set "bar"
  set "qux"</p>

<p>foo.bar
  foo.qux</p>

<p>::</p>

<p># Simulating a <code>for</code> loop using a <code>while</code> loop
  $mac for -&gt; init test incr body
    'w/new-scope
       | init
       | while test
           | body
           | incr</p>

<p>for (box i = 0) (i &lt; 10) (++ i)
    prn i</p>

<p>::</p>

<p># Simulating a <code>do..while</code> loop using a <code>while</code> loop
  $mac do -&gt; body {('while) test}
    'while %t
       | body
       | if ~ test
           &amp;break;</p>

<p>box i = 0
  do
    | prn i
    | ++ i
    while (i &lt; 10)</p>

<p>::</p>

<p># Infinite loop; be careful, the only way to stop it is to shut down the terminal!
  $mac 5ever -&gt; body
    'while %t
       body</p>

<p>5ever
    | prn 1
    | prn 2
    | prn 3
    | prn 4
    | prn "das mor den 4ever"</p>

<p>::</p>

<p># Macro to iterate over the elements of any list or string
  $mac w/each -&gt; {('=) x y} body
    w/uniq i len
      w/complex y
        'w/box len = y.length
           for (box i = 0) (i ~= len) (++ i)
             w/box x = y[i]
               body</p>

<p>w/each x = {1 2 3}
    | prn x
    | prn x + 5
    | prn;</p>

<p>::</p>

<p># Macro to iterate over the elements of any list or string in reverse order
  $mac w/each-rev -&gt; {('=) x y} body
    w/uniq i
      w/complex y
        'w/box i = y.length
           while i
             w/box x = y[-- i]
               body</p>

<p>w/each-rev x = {1 2 3}
    | prn x
    | prn x + 5
    | prn;</p>

<p>::</p>

<p># The built-in Array methods work very nicely with Nulan's -&gt; syntax
  {1 2 3}.for-each -&gt; x
    | prn x
    | prn x + 5
    | prn;</p>

<p>{1 2 3}.map -&gt; x
    x + 5</p>

<p>{1 2 3}.reduce -&gt; x y
    "(<a href="https://github.com/x" class="user-mention">@x</a> <a href="https://github.com/y" class="user-mention">@y</a>)"</p>

<p>::</p>

<p># An example of an unhygienic macro
  # Just like in Arc, it binds the symbol <code>it</code> to the test condition
  $mac aif -&gt; test <a href="https://github.com/rest" class="user-mention">@rest</a>
    w/box it = sym "it"
      'w/box it = test
         if it ,@:if rest.length &gt;= 2
                    w/box {x <a href="https://github.com/rest" class="user-mention">@rest</a>} = rest
                      'x (aif ,<a href="https://github.com/rest" class="user-mention">@rest</a>)
                    rest</p>

<p>aif 1 + 2
    it
    it</p>

<p>aif %f
    it
    it</p>

<p>::</p>

<p>def foo -&gt; x y
    x + y</p>

<p>$syntax-infix foo</p>

<p>1 foo 2    # Custom infix syntax</p>

<p>(foo) 1 2  # Wrapping in parens disables syntax</p>

<p>::</p>

<p># Array comprehensions
  box in</p>

<p>$mac for -&gt; x {('in) n y}
    'y.map -&gt; n x</p>

<p>$syntax-infix for 0 [ order "right" ]
  $syntax-infix in  0 [ order "right" ]</p>

<p>(x + 2) for x in {1 2 3}</p>

<p>::</p>

<p>#! /usr/bin/env nulan</p>

<p># A shell script that creates a simple HTTP server
  # Taken from <a href="http://nodejs.org/">http://nodejs.org/</a>
  box net = require "net"</p>

<p>box server = net.create-server -&gt; o
                 | o.write "Echo server\r\n"
                 | o.pipe o</p>

<p>server.listen 1337 "127.0.0.1"</p>

<h1>FAQ</h1>

<ul>
<li>
<p><strong>Q:</strong> Why doesn't this work?!</p>

<p>::</p>

<p>def foo -&gt; x
  bar x + 1</p>

<p>def bar -&gt; x
  x + 5</p>

<p>foo 20</p>

<p><strong>A:</strong> Nulan uses hyper-static scope, so you need to rearrange it so <code>foo</code> is defined after <code>bar</code>::</p>

<p>def bar -&gt; x
  x + 5</p>

<p>def foo -&gt; x
  bar x + 1</p>

<p>foo 20</p>
</li>
<li>
<p><strong>Q:</strong> Well, okay, but what about this?</p>

<p>::</p>

<p>$mac foo -&gt;
  '1 + 2</p>

<p>prn foo</p>

<p><strong>A:</strong> Nulan has a <em>very</em> strict separation between compile-time and run-time: things that exist at compile-time <strong>cannot</strong> be used at run-time in any way, shape, or form. And vice versa: things that exist at run-time cannot be used at compile-time.</p>

<p>Certain macros like <code>$mac</code> are prefixed with <code>$</code> which indicates that they are evaluated at compile-time. To make the above example work, you have to evaluate the expression at compile-time by using <code>$run</code>::</p>

<p>$mac foo -&gt;
  '1 + 2</p>

<p>$run
  prn foo</p>
</li>
<li>
<p><strong>Q:</strong> If there's such a strict separation between the two, why does this work?</p>

<p>::</p>

<p>def foo -&gt; x
  x + 1</p>

<p>$mac bar -&gt; x
  'foo x</p>

<p>bar 10</p>

<p><strong>A:</strong> Nulan replaces symbols with boxes. The <em>value</em> of the symbol <code>foo</code> is not available, but the <em>box</em> is.</p>

<p>The <code>'</code> macro returns boxes, which means that the <code>bar</code> macro returns the <em>box</em> for <code>foo</code>, not the <em>value</em> for <code>foo</code>. This is the <strong>only</strong> way that you can use run-time stuff at compile-time.</p>

<p>However, this would not work...</p>

<p>::</p>

<p>$mac bar -&gt; x
  foo x</p>

<p>...because it's trying to use the <em>value</em> of the <code>foo</code> symbol, which doesn't exist at compile-time.</p>

<p>In addition, if a <em>macro</em> is the first element of a list, it is evaluated at compile-time, which is why <code>bar 10</code> works. But <code>prn bar 10</code> would <strong>not</strong> work, because the macro <code>bar</code> isn't the first element of the list</p>
</li>
<li><p><strong>Q:</strong></p></li>
</ul>
      </section>
      <footer>
        <p><small>Hosted on <a href="https://pages.github.com">GitHub Pages</a> using the Dinky theme</small></p>
      </footer>
    </div>
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->
		
  </body>
</html>