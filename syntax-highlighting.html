<!DOCTYPE html>
<html>
  <head>
    <meta charset='utf-8' />

    <style>
      * {
        box-sizing: border-box;
      }

      html {
        height: 100%;
      }

      body {
        background-color: #080D11; /* #0f171f */
        color: #64B5F6; /* #7ea9d7 #8EB6E0 #78BAFF */
        margin: 0px;

        display: flex;
        flex-direction: horizontal;
      }

      #input {
        border-right: 1px solid #0D47A1;
      }

      #output {

      }

      #input, #output {
        margin: 0px;
        position: relative;
        line-height: 1.2em;
        min-height: 50em;
        padding: 25px;
        width: calc(78ch + 25px);
      }

      .syntax {
        color: #0D47A1; /* #E2E2E2 #e7915d #4d769f #3a5572 #5E6F82 #243547 #38516B #616467 #B1B1B1 #6F6F6F #006584 */
      }

      .special {
        color: #D32F2F; /* #b54a4a #D03B3B */
      }

      .literal {
        color: #26D92C; /* #36ce5d #1CE247 #47FF5E #24FF40 #49FF60 #1CEF37 #3EF355 */
      }

      .protocol {
        color: #FDD835; /* #F882FF #E654EF #BA68C8 */
      }

      .type {
        color: #FF8F00; /* #eac06c #e7ce5d #FFFA54 #FF9B5F */
      }

      .indent {
        position: absolute;
        height: 1.2em;
        margin-left: 0.35em;
        border-left: 1px solid #0D47A1; /* #131E27 */
      }

      .indent-end {
        position: absolute;
        height: 1em;
        margin-left: 0.35em;
        border-left: 1px solid #0D47A1;
        border-bottom: 1px solid #0D47A1;
        width: 3px;
        border-bottom-left-radius: 3px;
      }
    </style>
  </head>
  <body>
    <pre id="input" contentEditable="true"></pre>
    <pre id="output"></pre>

    <script>
      "use strict";


      const wrap = (type, text) =>
        "<span class='" + type + "'>" + escape(text) + "</span>";

      const bar =
        "<span class='indent'></span>";

      const bar_end =
        "<span class='indent-end'></span>";


      const syntax1 = (color) =>
        (output, stack, position, text) => {
          output.push(wrap(color, text[position.index]));
          ++position.index;
          ++position.column;
        };

      const open = (color, is_record) =>
        (output, stack, position, text) => {
          stack.push({ column: position.column, is_record });
          output.push(wrap(color, text[position.index]));
          ++position.index;
          ++position.column;
        };

      const close = (color) =>
        (output, stack, position, text) => {
          stack.pop();
          output.push(wrap(color, text[position.index]));
          ++position.index;
          ++position.column;
        };


      // TODO is this correct ?
      const find_endings = (index, text) => {
        let endings = 0;

        while (index < text.length) {
          const c = text[index];

          if (c === "\n") {
            break;

          } else if (c === "(" || c === "[" || c === "{") {
            ++endings;
            ++index;

          } else if (c === ")" || c === "]" || c === "}") {
            --endings;
            ++index;

          } else {
            ++index;
          }
        }

        return endings;
      };

      const whitespace = (output, stack, position, text) => {
        const a = [];

        const start = position.column;

        while (position.index < text.length) {
          const c = text[position.index];

          if (c === " ") {
            a.push(c);
            ++position.index;
            ++position.column;

          } else {
            break;
          }
        }

        const next = text[position.index];

        if (stack.length && start === 0) {
          let max = 0;

          // TODO is this correct ?
          const endings = find_endings(position.index, text) + stack.length;

          // TODO is the stack always in sorted order ?
          for (let i = 0; i < stack.length; ++i) {
            const x = stack[i].column;

            if (next === "\n" || x < a.length) {
              output.push(new Array(x - max + 1).join(" "));

              // TODO is this correct ?
              if (i >= endings) {
                output.push(bar_end);
              } else {
                output.push(bar);
              }

              max = x;
            }
          }

          // TODO is this correct ?
          if (a.length > max) {
            output.push(new Array(a.length - max + 1).join(" "));
          }

        } else {
          output.push(a.join(""));
        }
      };


      const specials = {
        "\n": (output, stack, position, text) => {
          output.push(text[position.index]);
          ++position.index;
          ++position.line;
          position.column = 0;

          whitespace(output, stack, position, text);
        },

        " ": whitespace,

        "#": (output, stack, position, text) => {
          const a = [];

          while (position.index < text.length) {
            const c = text[position.index];

            if (c === "\n") {
              break;

            } else {
              a.push(c);
              ++position.index;
              ++position.column;
            }
          }

          output.push(wrap("syntax", a.join("")));
        },

        // TODO handle newlines
        // TODO handle escapes, etc.
        "\"": (output, stack, position, text) => {
          const a = [text[position.index]];

          ++position.index;
          ++position.column;

          while (position.index < text.length) {
            const c = text[position.index];

            a.push(c);
            ++position.index;
            ++position.column;

            if (c === "\"") {
              break;
            }
          }

          output.push(wrap("literal", a.join("")));
        },

        "&": syntax1("syntax"),
        ",": syntax1("syntax"),
        "@": syntax1("syntax"),

        ".": (output, stack, position, text) => {
          // TODO a tiny bit hacky
          syntax1("syntax")(output, stack, position, text);
          output.push(wrap("literal", parse_variable(position, text)));
        },

        "(": open("syntax", false),
        "[": open("syntax", false),
        "{": open("syntax", true),
        ")": close("syntax"),
        "]": close("syntax"),
        "}": close("syntax")
      };


      const variable = (stack, position, text, s) => {
        if (s === "_") {
          return wrap("syntax", s);

        } else if (s === "->" || s === "<=" || s === "~") {
          return wrap("syntax", s);

        } else if (s === "::") {
          return wrap("syntax", s);

        } else if (s[0] === "*") {
          return wrap("literal", s);

        } else if (s[0] === "$") {
          return wrap("protocol", s);

        } else if (/^[0-9]+$/.test(s)) {
          return wrap("literal", s);

        } else if (/^[^a-z]+$/.test(s)) {
          return wrap("special", s);

        } else if (/^[A-Z]/.test(s)) {
          return wrap("type", s);

        } else {
          // TODO hacky
          // TODO is this correct ?
          if (stack.length &&
              stack[stack.length - 1].is_record &&
              (find(position.index, text, "<=") ||
               find(position.index, text, "::") ||
               find_end(position.index, text))) {
            return wrap("literal", s);
          } else {
            return escape(s);
          }
        }
      };


      // TODO hacky
      const find = (index, text, s) => {
        const a = [];

        while (index < text.length) {
          if (text[index] === " ") {
            ++index;
          } else {
            break;
          }
        }

        return parse_variable({ index, column: 0 }, text) === s;
      };

      // TODO hacky
      const find_end = (index, text) => {
        const a = [];

        while (index < text.length) {
          const c = text[index];

          if (c === " " || c === "\n" || !specials[c]) {
            ++index;
          } else {
            break;
          }
        }

        return text[index] === "}";
      };


      // TODO handle the other entities ?
      const escape = (s) =>
        // TODO is this correct ?
        s.replace(/</g, "&lt;");

      const parse_variable = (position, text) => {
        const a = [];

        while (position.index < text.length) {
          const c = text[position.index];

          if (specials[c]) {
            break;

          } else {
            a.push(c);
            ++position.index;
            ++position.column;
          }
        }

        return a.join("");
      };


      const markup = (text) => {
        const output = [];
        const stack = [];

        const position = { column: 0, line: 0, index: 0 };

        while (position.index < text.length) {
          const c = text[position.index];

          if (specials[c]) {
            specials[c](output, stack, position, text);

          } else {
            output.push(variable(stack, position, text, parse_variable(position, text)));
          }
        }

        return output.join("");
      };


      const input = document.getElementById("input");
      const output = document.getElementById("output");

      input.textContent = localStorage["text"] || "";
      output.innerHTML = markup(input.textContent);

      let timer = null;

      input.addEventListener("input", () => {
        clearTimeout(timer);

        timer = setTimeout(() => {
          localStorage["text"] = input.textContent;
          output.innerHTML = markup(input.textContent);
        }, 300);
      }, true);
    </script>
  </body>
</html>
