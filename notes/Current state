(TYPE (Foo a))

(TYPE Color
  *red
  *orange
  *yellow
  *green
  *blue
  *indigo
  *violet)

(TYPE Rgb
  (*rgba Integer Integer Integer Number))

(TYPE (List a)
  *empty
  (*value a (List a)))

(TYPE Foo
  (REQUIRE ($foo a)
    (*foo a)))

(PROTOCOL ($transform a)
  transform :: (-> (a b) (-> b c) (a c)))

(PROTOCOL ($transform a)
  transform :: (-> (a b) (-> b c) (a c)))

(CONSTANT chain :: (REQUIRE ($transform a) ($flatten a)
                     (-> (a b) (-> b (a c)) (a c)))
  (-> a fn
    (flatten (transform a fn))))

(FUNCTION chain :: (REQUIRE ($transform a) ($flatten a)
                     (-> (a b) (-> b (a c)) (a c)))
  (chain a fn)
  : (flatten (transform a fn)))

(LOAD-PACKAGE "flatten"
  (github "nulan/flatten" "v2.0.0"))

(IMPORT "nulan:default/standard.nul")

(IMPORT "nulan:default/node.nul")
(IMPORT "nulan:default/browser.nul")

(IMPORT "default/foo.nul")

(IMPORT "package:flatten/default/foo.nul")

(IMPORT "package:flatten/module/flatten.nul"
  $flatten
  flatten)

(IMPORT "package:flatten/default/foo.nul"
  (PROVIDE ($transform Maybe)))

(LOCAL-IMPORT "package:flatten/default/foo.nul"
  transform <= map
  (transform ...))

(LOCAL-IMPORT "package:flatten/default/foo.nul"
  (PROVIDE ($transform Maybe))
  (transform ...))

(CONSTANT maybe-transform :: (-> ...)
  (LOCAL-IMPORT "package:flatten/default/foo.nul"
    (PROVIDE ($transform Maybe))
    transform))

(PROVIDE ($transform Maybe)
  transform <= map)

(PROVIDE ($transform Maybe)
  (transform a b)
  : (map a b))

(IMPORT "foo/bar.nul"
  a <= d
  b
  c
  Maybe
  *some
  *none)

(LOCAL-PROVIDE ($flatten Maybe)
  flatten <= (-> ...)
  (flatten ...))

(LOCAL-PROVIDE ($flatten Maybe)
  (flatten a b)
  : ...
  (flatten ...))

(IF test
  then
  else)

(UNSAFE-FFI-IMPORT { target <= javascript
                     file <= "ffi/foo/bar.js" }
  a :: (-> Integer Integer Integer)
  b :: Integer
  c :: Integer
  d :: (Foo Integer))

(FUNCTION foo<< :: (-> a Foo)
  (foo<< a)
  : ...)

(FUNCTION <<foo :: (-> Foo a)
  (<<foo a)
  : ...)

(CONSTANT foo :: (-> (-> Integer Integer Integer) Integer)
  (-> a (a 1 2)))

(LOCAL
  a <= 1
  (+ a 2))

(LOCAL
  a <= 1
  b <= 2
  (+ a b))

(LOCAL
  a
  <= (+ 1 2)

  b
  <= (+ 2 3)

  (+ a b))

(LOOP loop
  a <= 1
  b <= 2
  (loop a b))

(FUNCTION foo :: (-> (-> Integer Integer Integer) Integer)
  (foo a)
  : (a 1 2))

(FUNCTION foo :: (-> Text Text)
  (foo a)
  : a)

(FUNCTION bar :: (-> Integer Integer)
  (bar 1)
  : 2

  (bar a)
  : (+ (bar 1) a))

(REWRITE-RULE
  (QUX ~@a)
  : &(+ ~@a))

(MUTUALLY-RECURSIVE
  (FUNCTION even? :: (-> Integer Boolean)
    (even? 0)
    : true

    (even? a)
    : (odd? (- a 1)))

  (FUNCTION odd? :: (-> Integer Boolean)
    (odd? 0)
    : false

    (odd? a)
    : (even? (- a 1))))

(MUTUALLY-RECURSIVE
  (PROTOCOL ($foo a)
    foo :: (REQUIRE ($bar a)
             (-> a a)))

  (PROTOCOL ($bar a)
    bar :: (REQUIRE ($foo a)
             (-> a a))))

(MUTUALLY-RECURSIVE
  (TYPE Foo
    (*foo Bar))

  (TYPE Bar
    (*bar Foo)))

(MUTUALLY-RECURSIVE
  (REWRITE-RULE
    (FOO ~n <= ~v)
    : &(BAR ~n ~v)

    (FOO ~v)
    : &(BAR ~v))

  (REWRITE-RULE
    (BAR ~a ~@b)
    : (MATCH a
        &~n <= ~v
        : &(QUX ~n ~v ~@b)

        v
        : &(QUX 1 ~v ~@b))))

(foo -> a b (+ a b))
(foo (echo -> a b (+ a b)))

(MUTUALLY-RECURSIVE
  (REWRITE-RULE
    (UNSTREAM (STREAM ~a))
    : a

    (UNSTREAM ~a)
    : &(unstream ~a))

  (REWRITE-RULE
    (STREAM (UNSTREAM ~a))
    : a

    (STREAM ~a)
    : &(stream ~a)))

(CHAIN
  a <= a
  b <= b
  c)

(CHAIN
  x <= (read-file "foo")
  (log x)
  (write-file "bar" x)
  (reply null))

(chain (read-file "foo") -> x
  (chain (log x) -> _ :: Null
    (transform (write-file "bar" x) -> _ :: Null
      null)))

(TRANSFORM
  a <= 1
  b <= 2
  c <= 3
  (+ a b c))

(MATCHES [ a b c ]
  [ 1 2 3 ]
  : 1

  [ 1 2 a ]
  : 2

  [ 1 a b ]
  : 3

  [ a b c ]
  : 4)

[ 1 2 3 ]

[ 1
  2
  3 ]

{ a b }

{ a <= 1 b <= 2 }

{ a <= 1
  b <= 2 }

{ @a
  b <= 2
  c <= 3 }

foo.bar

(MATCH a
  _
  : 1

  a
  : 2

  1
  : 3

  "foo"
  : 4

  { a b c }
  : 5

  { a <= b c <= d }
  : { b <= a d <= c }

  (*foo 1)
  : 6)


# Unsure

(PRAGMA { phase <= run-time
          target <= javascript }
  foo)

(METADATA impure inline-function synchronous
  foo)

(INLINE
  (-> foo bar))

(IMPORT "package:flatten/module/flatten.nul"
  (TYPE Foo
    *bar
    *qux))
