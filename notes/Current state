(TYPE (Foo a))

(TYPE Color
  *red
  *orange
  *yellow
  *green
  *blue
  *indigo
  *violet)

(TYPE Rgb
  (*rgba Integer Integer Integer Number))

(TYPE Rbg
  (*rgba { red :: Integer
           blue :: Integer
           green :: Integer
           alpha :: Number }))

(MATCHES [ foo ]
  [ (*rgba { red blue green alpha }) ]
  : (*rgba { red blue green alpha })

  [ (*rgba { red blue green alpha }) ]
  : b)

(MATCH foo
  (*rgba { red blue green alpha })
  : (*rgba { red blue green alpha })

  (*rgba { red blue green alpha })
  : b)

(TYPE (List a)
  *empty
  (*value a (List a)))

(TYPE Foo
  (REQUIRE ($foo a)
    (*foo a)))


# The type and all tags are made public
(PUBLIC
  (TYPE Foo
    *foo))

# The type is made public (tags are private)
(ABSTRACT-TYPE Foo
  *foo)

# The constant is made public
(PUBLIC
  (CONSTANT ...))

# The protocol and all functions are made public
(PUBLIC
  (PROTOCOL ($foo a) ...))

# The provide is made public
(PUBLIC
  (PROVIDE ($foo Foo) ...))


(PROTOCOL ($transform a)
  transform :: (-> (a b) (-> b c) (a c)))

(CONSTANT chain :: (REQUIRE ($transform a) ($flatten a)
                     (-> (a b) (-> b (a c)) (a c)))
  (-> a fn
    (flatten (transform a fn))))

(FUNCTION chain :: (REQUIRE ($transform a) ($flatten a)
                     (-> (a b) (-> b (a c)) (a c)))
  [ a fn ]
  : (flatten (transform a fn)))

(DEPENDENCY "flatten"
  (github "nulan/flatten" "v2.0.0"))

(USE "package:nulan-standard/task.nul")

(USE "package:nulan-nodejs/node.nul")
(USE "package:nulan-browser/browser.nul")

(USE "local:foo.nul")

(USE "package:flatten/foo.nul")

(USE "package:flatten/module/flatten.nul"
  $flatten
  flatten)

(USE "package:flatten/foo.nul"
  (PROVIDE ($transform Maybe)))

(LOCAL-USE "package:flatten/foo.nul"
  transform <= map
  (transform ...))

(LOCAL-USE "package:flatten/foo.nul"
  (PROVIDE ($transform Maybe))
  (transform ...))

(CONSTANT maybe-transform :: (-> ...)
  (LOCAL-USE "package:flatten/foo.nul"
    (PROVIDE ($transform Maybe))
    transform))

(PROVIDE ($transform Maybe)
  (CONSTANT transform :: (-> ...)
    map))

(PROVIDE ($transform Maybe)
  (FUNCTION transform :: (-> ...)
    [ a b ]
    : (map a b)))

(USE "local:foo/bar.nul"
  a <= d
  b
  c
  Maybe
  *some
  *none)

(LOCAL-PROVIDE ($flatten Maybe)
  (CONSTANT flatten :: (-> ...)
    (-> ...))
  (flatten ...))

(LOCAL-PROVIDE ($flatten Maybe)
  (FUNCTION flatten :: (-> ...)
    [ a b ]
    : ...)
  (flatten ...))

(IF test
  then
  else)

(UNSAFE-FFI-USE { target <= javascript
                  file <= "local:ffi/foo/bar.js" }
  a :: (-> Integer Integer Integer)
  b :: Integer
  c :: Integer
  d :: (Foo Integer))

(PROTOCOL ($<< a b)
  << :: (-> a b))

(PROVIDE ($<< a Foo)
  (FUNCTION << :: (-> a Foo)
    [ a ]
    : ...))

(PROVIDE ($<< Foo a)
  (FUNCTION << :: (-> Foo a)
    [ a ]
    : ...))

(TYPE (Result a b)
  (*success a)
  (*failure b))

(PROTOCOL ($result<< a b c)
  result<< :: (-> a (Result b c)))

(PROVIDE (REQUIRE ($<< a b)
           ($result<< a b Never))
  (FUNCTION result<< :: (-> a (Result b Never))
    [ a ]
    : (*success (<< a))))

(PROVIDE (REQUIRE ($result<< a b c)
           ($<< a (Result b c)))
  (FUNCTION << :: (-> a (Result b c))
    [ a ]
    : (result<< a)))

(PROVIDE ($<< (Result a _) (Maybe a))
  (FUNCTION << :: (-> (Result a _) (Maybe a))
    [ (*success a) ]
    : (*some a)

    [ (*failure _) ]
    : *none))

(PROVIDE ($<< (Maybe a) (Result a Null))
  (FUNCTION << :: (-> (Maybe a) (Result a Null))
    [ (*some a) ]
    : (*success a)

    [ *none ]
    : (*failure *null)))

(FUNCTION maybe<< :: (REQUIRE ($result<< a b _)
                       (-> a (Maybe b)))
  [ a ]
  : (<< (<< a)))

(PROVIDE (REQUIRE ($result<< a b _)
           ($<< a (Maybe b)))
  (FUNCTION << :: (-> a (Maybe b))
    [ a ]
    : (<< (<< a))))

(<< 5)

(result<< 5)

(maybe<< 5)

(CHAIN
  foo <= ...
  bar <= ...
  (<< 5))

(FUNCTION foo<< :: (-> a Foo)
  [ a ]
  : ...)

(FUNCTION <<foo :: (-> Foo a)
  [ a ]
  : ...)

(CONSTANT foo :: (-> (-> Integer Integer Integer) Integer)
  (-> a (a 1 2)))

(LOCAL
  a <= 1
  (+ a 2))

(LOCAL
  a <= 1
  b <= 2
  (+ a b))

(LOCAL
  a
  <= (+ 1 2)

  b
  <= (+ 2 3)

  (+ a b))

(LOOP loop
  a <= 1
  b <= 2
  (loop a b))

(FUNCTION foo :: (-> (-> Integer Integer Integer) Integer)
  [ a ]
  : (a 1 2))

(FUNCTION foo :: (-> Text Text)
  [ a ]
  : a)

(FUNCTION bar :: (-> Integer Integer)
  [ 1 ]
  : 2

  [ a ]
  : (+ (bar 1) a))


(REWRITE-RULE QUX
  [ ~@a ]
  : &(+ ~@a))


(REWRITE-RULE ALIAS
  [ ~n <= ~v ]
  : &(REWRITE-RULE ~n
       []
       : &~~v))

(ALIAS FOO <= (+ 5 10 20))


(REWRITE-RULE CHAIN-MATCH
  [ ~value ~@matches ]
  : (LOCAL
      a <= (UNIQUE-SYMBOL)
      &(CHAIN
         ~a <= ~value
         (MATCHES [ ~a ]
           ~@matches))))

(CHAIN-MATCH foo
  [ *none ]
  : 1

  [ (*some a) ]
  : 2)


(MUTUALLY-RECURSIVE
  (FUNCTION even? :: (-> Integer Boolean)
    [ 0 ]
    : true

    [ a ]
    : (odd? (- a 1)))

  (FUNCTION odd? :: (-> Integer Boolean)
    [ 0 ]
    : false

    [ a ]
    : (even? (- a 1))))

(MUTUALLY-RECURSIVE
  (PROTOCOL ($foo a)
    foo :: (REQUIRE ($bar a)
             (-> a a)))

  (PROTOCOL ($bar a)
    bar :: (REQUIRE ($foo a)
             (-> a a))))

(MUTUALLY-RECURSIVE
  (TYPE Foo
    (*foo Bar))

  (TYPE Bar
    (*bar Foo)))

(MUTUALLY-RECURSIVE
  (REWRITE-RULE FOO
    [ ~n <= ~v ]
    : &(BAR ~n ~v)

    [ ~v ]
    : &(BAR ~v))

  (REWRITE-RULE BAR
    [ ~a ~@b ]
    : (MATCHES [ a ]
        [ &~n <= ~v ]
        : &(QUX ~n ~v ~@b)

        [ v ]
        : &(QUX 1 ~v ~@b))))

(foo -> a b (+ a b))
(foo (-> a b (+ a b)))
(foo (echo -> a b (+ a b)))
(foo (ECHO -> a b (+ a b)))

(MUTUALLY-RECURSIVE
  (REWRITE-RULE UNSTREAM
    [ (STREAM ~a) ]
    : a

    [ ~a ]
    : &(unstream ~a))

  (REWRITE-RULE STREAM
    [ (UNSTREAM ~a) ]
    : a

    [ ~a ]
    : &(stream ~a)))

(CHAIN
  a <= a
  b <= b
  c)

(CHAIN
  x <= (read-file "foo")
  (log x)
  (write-file "bar" x)
  (<< null))

(chain (read-file "foo") -> x
  (chain (log x) -> *null
    (transform (write-file "bar" x) -> *null
      null)))

(TRANSFORM
  a <= 1
  b <= 2
  c <= 3
  (+ a b c))

(MATCHES [ a b c ]
  [ 1 2 3 ]
  : 1

  [ 1 2 a ]
  : 2

  [ 1 a b ]
  : 3

  [ a b c ]
  : 4)

[ 1 2 3 ]

[ 1
  2
  3 ]

(*foo { a b })

(*foo { a <= 1 b <= 2 })

(*foo { a <= 1
        b <= 2 })

(*foo
  { a <= 1
    b <= 2 })

(MATCH a
  _
  : 1

  a
  : 2

  1
  : 3

  "foo"
  : 4

  (*foo { a b c })
  : 5

  (*foo { a <= b c <= d })
  : (*foo { b <= a d <= c })

  (*foo 1)
  : 6)


# Unsure

(PRAGMA { phase <= run-time
          target <= javascript }
  foo)

(METADATA impure inline-function synchronous
  foo)

(INLINE
  (-> foo bar))

(USE "package:flatten/module/flatten.nul"
  (TYPE Foo
    *bar
    *qux))
