(TYPE Color
  *red
  *orange
  *yellow
  *green
  *blue
  *indigo
  *violet)

(TYPE Rgb
  (*rgba Integer Integer Integer Number))

(RECORD Rbga
  { red :: Integer
    blue :: Integer
    green :: Integer
    alpha :: Number })

(MATCHES [ foo ]
  [ (*rgba { red blue green alpha }) ]
  : (*rgba { red blue green alpha })

  [ (*rgba { red blue green alpha }) ]
  : b)

(MATCH foo
  | (*rgba { red blue green alpha })
  : (*rgba { red blue green alpha })

  | (*rgba { red blue green alpha })
  : b)

(TYPE (List a)
  *empty
  (*value a (List a)))

(TYPE Foo
  (IMPLICIT a
    (REQUIRE ($foo a)
      (*foo a))))


(PROTOCOL ($flatten a)
  flatten :: (IMPLICIT b
               (-> (a (a b)) (a b))))


(FUNCTION state-monad :: (IMPLICIT a
                           (-> a Type))
  [ value ]
  : (IMPLICIT a
      (State a value)))

(PROVIDE ($flatten (IMPLICIT a
                     (=> value (State a value))))
  (FUNCTION flatten :: (IMPLICIT a value
                         (-> (State (State a value)) (State a value)))
    ...))


(PROTOCOL ($transform a)
  transform :: (IMPLICIT b c
                 (REQUIRE ($foo a)
                   (-> (a b) (-> b c) (a c)))))

(CONSTANT chain :: (IMPLICIT a b c
                     (REQUIRE ($transform a) ($flatten a)
                       (-> (a b) (-> b (a c)) (a c))))
  (=> a fn
    (flatten (transform a fn))))

(FUNCTION chain :: (IMPLICIT a b c
                     (REQUIRE ($transform a) ($flatten a)
                       (-> (a b) (-> b (a c)) (a c))))
  [ a fn ]
  : (flatten (transform a fn)))

(IMPORT (github "nulan/flatten" "v2.0.0" "package.nul"))

(IMPORT (github "nulan/nulan-standard" "v2.0.0" "unsafe/package.nul"))

(IMPORT (github "nulan/nulan-nodejs" "v2.0.0" "package.nul"))
(IMPORT (github "nulan/nulan-browser" "v2.0.0" "package.nul"))

(IMPORT (local "foo.nul"))

(IMPORT (local "flatten/foo.nul"))

(IMPORT (local "flatten/module/flatten.nul")
  $flatten
  flatten)

(IMPORT (local "flatten/foo.nul")
  transform-maybe)

(LOCAL-IMPORT (local "flatten/foo.nul")
  (transform ...))

(LOCAL-IMPORT (local "flatten/foo.nul")
  transform <= map
  (transform ...))

(LOCAL-IMPORT (local "flatten/foo.nul")
  transform-maybe
  (transform ...))

(CONSTANT maybe-transform :: (-> ...)
  (LOCAL-IMPORT (local "flatten/foo.nul")
    transform-maybe
    transform))

(PROVIDE transform-maybe :: ($transform Maybe)
  map)

(PROVIDE transform-maybe :: ($transform Maybe)
  (LOCAL-FUNCTION (-> ...)
    [ a b ]
    : ...))

(PROVIDE-FUNCTION transform-maybe :: ($transform Maybe)
  [ a b ]
  : (map a b))


(LOCAL-RECORD
  (FUNCTION transform :: (-> (Maybe a) (-> a b) (Maybe b))
    [ *none _ ]
    : *none

    [ (*some a) f ]
    : (*some (f a))))

(CONSTANT transform-maybe :: (Transform Maybe)
  { transform <=
    (-> a f
      (MATCH a
        | *none
        : *none

        | (*some a)
        : (*some (f a)))) })


(PROTOCOL (Transform a)
  transform :: (-> (a b) (-> b c) (a c)))

(FUNCTION foo :: (-> @(Transform a) a b c)
  [ a b ]
  : (transform a b c))


(RECORD-TYPE (Transform a)
  { transform :: (-> (a b) (-> b c) (a c)) })

(IMPLICIT-RECORD transform-maybe :: (Transform Maybe)
  (FUNCTION transform :: (-> (Maybe a) (-> a b) (Maybe b))
    [ *none _ ]
    : *none

    [ (*some a) f ]
    : (*some (f a))))

(FUNCTION foo :: (-> @(Transform a) a b c)
  [ @m a b ]
  : (m.transform a b c))


(PROTOCOL (Transform a)
  (-> (a b) (-> b c) (a c)))

(IMPLEMENT transform-maybe :: (Transform Maybe)
  (FUNCTION transform :: (-> (Maybe a) (-> a b) (Maybe b))
    [ *none _ ]
    : *none

    [ (*some a) f ]
    : (*some (f a))))

(IMPLEMENT-FUNCTION transform-maybe :: (Transform Maybe)
  [ *none _ ]
  : *none

  [ (*some a) f ]
  : (*some (f a)))

(FUNCTION foo :: (-> @(Transform a) a b c)
  [ @transform a b ]
  : (transform a b c))


(RECORD-TYPE (Transform a)
  { transform :: (-> (a b) (-> b c) (a c)) })

(CONSTANT-RECORD @transform-maybe :: (Transform Maybe)
  (FUNCTION transform :: (-> (Maybe a) (-> a b) (Maybe b))
    [ *none _ ]
    : *none

    [ (*some a) f ]
    : (*some (f a))))

(FUNCTION foo :: (-> @(Transform a) a b c)
  [ @{ transform } a b ]
  : (transform a b c))

(FUNCTION foo :: (-> @(Transform a) a b c)
  [ @m a b ]
  : (m.transform a b c))

(LOCAL
  @m <= { transform <= ... }
  (foo 1 2))


(TYPE-ALIAS (Transform a b c)
  (-> (a b) (-> b c) (a c)))

(FUNCTION transform-maybe :: (-> (Maybe a) (-> a b) (Maybe b))
  [ *none _ ]
  : *none

  [ (*some a) f ]
  : (*some (f a)))

(FUNCTION foo :: (-> @(Transform a b c) a b c)
  [ @transform a b ]
  : (transform a b c))


(FUNCTION foo :: (REQUIRE ($transform a)
                   (-> a b c))
  [ a b ]
  : (transform a b c))


(USE "local:foo/bar.nul"
  a <= d
  b
  c
  Maybe
  *some
  *none)

(LOCAL-PROVIDE ($flatten Maybe)
  (CONSTANT flatten :: (-> ...)
    (-> ...))
  (flatten ...))

(LOCAL-PROVIDE ($flatten Maybe)
  (FUNCTION flatten :: (-> ...)
    [ a b ]
    : ...)
  (flatten ...))

(IF test
  then
  else)

(UNSAFE-FFI-USE { target <= javascript
                  file <= "local:ffi/foo/bar.js" }
  a :: (-> Integer Integer Integer)
  b :: Integer
  c :: Integer
  d :: (Foo Integer))

(PROTOCOL ($<< a b)
  << :: (-> a b))

(PROVIDE $<<
  (FUNCTION << :: (IMPLICIT a
                    (-> a Foo))
    [ a ]
    : ...))

(PROVIDE $<<
  (FUNCTION << :: (IMPLICIT a
                    (-> Foo a))
    [ a ]
    : ...))

(TYPE (Result a b)
  (*success a)
  (*failure b))

(PROTOCOL ($result<< a b c)
  result<< :: (-> a (Result b c)))

(PROVIDE $result<<
  (FUNCTION result<< :: (IMPLICIT a b
                          (REQUIRE ($<< a b)
                            (-> a (Result b Never))))
    [ a ]
    : (*success (<< a))))

(PROVIDE $<<
  (FUNCTION << :: (IMPLICIT
                    (REQUIRE ($result<< a b c)
                      (-> a (Result b c))))
    [ a ]
    : (result<< a)))

(PROVIDE $<<
  (FUNCTION << :: (IMPLICIT a
                    (-> (Result a _) (Maybe a)))
    [ (*success a) ]
    : (*some a)

    [ (*failure _) ]
    : *none))

(PROVIDE $<<
  (FUNCTION << :: (IMPLICIT a
                    (-> (Maybe a) (Result a Null)))
    [ (*some a) ]
    : (*success a)

    [ *none ]
    : (*failure *null)))

(FUNCTION maybe<< :: (IMPLICIT a b
                       (REQUIRE ($result<< a b _)
                         (-> a (Maybe b))))
  [ a ]
  : (<< (<< a)))

(PROVIDE $<<
  (FUNCTION << :: (IMPLICIT a b
                    (REQUIRE ($result<< a b _)
                      (-> a (Maybe b))))
    [ a ]
    : (<< (<< a))))

(<< 5)

(result<< 5)

(maybe<< 5)

(CHAIN
  foo <= ...
  bar <= ...
  (<< 5))

(FUNCTION foo<< :: (IMPLICIT a
                     (-> a Foo))
  [ a ]
  : ...)

(FUNCTION <<foo :: (IMPLICIT a
                     (-> Foo a))
  [ a ]
  : ...)

(CONSTANT foo :: (-> (-> Integer Integer Integer) Integer)
  (-> a (a 1 2)))

(LOCAL
  a <= 1
  (+ a 2))

(LOCAL
  a <= 1
  b <= 2
  (+ a b))

(LOCAL
  a
  <= (+ 1 2)

  b
  <= (+ 2 3)

  (+ a b))

(LOOP loop
  a <= 1
  b <= 2
  (loop a b))

(FUNCTION foo :: (-> (-> Integer Integer Integer) Integer)
  [ a ]
  : (a 1 2))

(FUNCTION foo :: (-> Text Text)
  [ a ]
  : a)

(FUNCTION bar :: (-> Integer Integer)
  [ 1 ]
  : 2

  [ a ]
  : (+ (bar 1) a))


(REWRITE-RULE QUX
  [ ~@a ]
  : &(+ ~@a))


(REWRITE-RULE ALIAS
  [ ~n <= ~v ]
  : &(REWRITE-RULE ~n
       []
       : &~~v))

(ALIAS FOO <= (+ 5 10 20))


(REWRITE-RULE CHAIN-MATCH
  [ ~value ~@matches ]
  : (LOCAL
      a <= (UNIQUE-SYMBOL)
      &(CHAIN
         ~a <= ~value
         (MATCH ~a
           ~@matches))))

(CHAIN-MATCH foo
  | *none
  : 1

  | (*some a)
  : 2)


(MUTUALLY-RECURSIVE
  (FUNCTION even? :: (-> Integer Boolean)
    [ 0 ]
    : true

    [ a ]
    : (odd? (- a 1)))

  (FUNCTION odd? :: (-> Integer Boolean)
    [ 0 ]
    : false

    [ a ]
    : (even? (- a 1))))

(MUTUALLY-RECURSIVE
  (PROTOCOL ($foo a)
    foo :: (REQUIRE ($bar a)
             (-> a a)))

  (PROTOCOL ($bar a)
    bar :: (REQUIRE ($foo a)
             (-> a a))))

(MUTUALLY-RECURSIVE
  (TYPE Foo
    (*foo Bar))

  (TYPE Bar
    (*bar Foo)))

(MUTUALLY-RECURSIVE
  (REWRITE-RULE FOO
    [ ~n <= ~v ]
    : &(BAR ~n ~v)

    [ ~v ]
    : &(BAR ~v))

  (REWRITE-RULE BAR
    [ ~a ~@b ]
    : (MATCH a
        | &~n <= ~v
        : &(QUX ~n ~v ~@b)

        | v
        : &(QUX 1 ~v ~@b))))

(foo -> a b (+ a b))
(foo (-> a b (+ a b)))
(foo (echo -> a b (+ a b)))
(foo (ECHO -> a b (+ a b)))

(MUTUALLY-RECURSIVE
  (REWRITE-RULE UNSTREAM
    [ (STREAM ~a) ]
    : a

    [ ~a ]
    : &(unstream ~a))

  (REWRITE-RULE STREAM
    [ (UNSTREAM ~a) ]
    : a

    [ ~a ]
    : &(stream ~a)))

(CHAIN
  a <= a
  b <= b
  c)

(CHAIN
  x <= (read-file "foo")
  (log x)
  (write-file "bar" x)
  (<< null))

(chain (read-file "foo") -> x
  (chain (log x) -> *null
    (transform (write-file "bar" x) -> *null
      null)))

(TRANSFORM
  a <= 1
  b <= 2
  c <= 3
  (+ a b c))

(MATCHES [ a b c ]
  [ 1 2 3 ]
  : 1

  [ 1 2 a ]
  : 2

  [ 1 a b ]
  : 3

  [ a b c ]
  : 4)

[ 1 2 3 ]

[ 1
  2
  3 ]

(*foo { a b })

(*foo { a <= 1 b <= 2 })

(*foo { a <= 1
        b <= 2 })

(*foo
  { a <= 1
    b <= 2 })

(MATCH a
  | _
  : 1

  | a
  : 2

  | 1
  : 3

  | "foo"
  : 4

  | (*foo { a b c })
  : 5

  | (*foo { a <= b c <= d })
  : (*foo { b <= a d <= c })

  | (*foo 1)
  : 6)


(ATTRIBUTES INLINE (TARGET JAVASCRIPT) (PHASE COMPILE)
  ...)


(ASSERT (equal? (foo 1) bar)
  (+ 1 2))


(ASSERTIONS
  (equal? foo bar)

  (test (foo (bar qux))))


(PROTOCOL ($unsafe-execute-main a)
  unsafe-execute-main :: (-> a Null))


# Unsure

(ABSTRACT
  (TYPE (Foo a)
    *foo
    (*bar a)))

(TAG->CONSTANT *foo)

(PROVIDE { public }
  (TAG->CONSTANT *foo))

(PUBLIC-TAG->CONSTANT
  *foo)

(USE-PREFIX "package:flatten/module/flatten.nul"
  flatten-
  flatten-foo
  flatten-bar)


(foo @bar ...) # equivalent to (foo (bar ...))

(foo @bar @qux ...) # equivalent to (foo (bar (qux ...)))


(TYPE Foo :: (-> $a $b Type)
  (*foo $a))

(TYPE Rgb :: Type
  (*rgba Integer Integer Integer Number))

(ASSERTIONS
  (CHAIN
    foo <= (read-file "foo")
    (<< (equal? foo bar))))

#/(ASSERTIONS
  (flatten
    (transform (read-file "foo") -> foo
      (<< (equal? foo bar)))))/#
