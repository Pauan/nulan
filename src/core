:export

($eval:do (var $do)
          ($mac! $do -> @args
            `($eval:do ,@args ()))
          ())

($do (var $mac)
     ($mac! $mac -> n v
       `($do (var n)
             ($mac! n v))))

($mac $var -> @args
  `($do:var ,@args))

($mac def -> n v
  `(do (var n)
       (set! n v)))

($mac let -> @args body
  `(w/new-scope
     (var ,@args)
     body))

($mac lazy -> body
  `(lazy-thunk -> body))

#|(def has? -> x key
  (place x key -> _ has has))

(def get -> x key
  (place x key -> value value))|#



(def foldl -> init a f
  ((foldr a (-> x x) -> x y
     (-> init
       (y (f init x))))
   init))

(def foldr -> a init f
  ((foldl (-> x x) a -> x y
     (-> init
       (x (f y init))))
   init))


(def nil? -> x
  (is x nil))

(def foldl -> init a f
  (let a = (->cons a)
    (if (nil? a)
      init
      (foldl (f init (car a)) (cdr a) f))))

(def foldr -> a init f
  (let a = (->cons a)
    (if (nil? a)
      init
      (f (car a) (foldr (cdr a) init f)))))

(def iterate -> a f :lazy
  (let a = (->cons a)
    (if (nil? a)
      nil
      (f (car a) (iterate (cdr a) f)))))

(def map -> a f
  (iterate a -> x y
    (cons (f x) y)))

(def keep -> a f
  (iterate a -> x y
    (if (f x)
      (cons x y)
      y)))

(def range -> (>= min 0) (max = infinity) (step = 1) :lazy
  (if (< min max)
        (cons min (range (+ min step) max step))
      (> min max)
        (cons min (range (- min step) max step))
      nil))


(def into -> x y
  (foldl x y -> x y
    (push x y)))



($mac w/sym -> @args body
  `(let ,@(map args -> x
            `(x = (sym ,"@x")))
     body))

($mac w/uniq -> @args body
  `(let ,@(map args -> x
            `(x = (uniq)))
     body))

($mac and -> x @args
  (w/uniq u
    (if (len? args)
      `(let u = x
         (if u (and ,@args) u))
      x)))

($mac or -> x @args
  (w/uniq u
    (if (len? args)
      `(let u = x
         (if u u (or ,@args)))
      x)))

($mac if-let -> `(x = y) yes no
  (w/uniq u
    `(let u = y
       (if u (let x = u yes) no))))

($mac keys -> @args
  `(var ,@(map args -> x
            `(x = (key ,"@x")))))

($mac w/var -> @args body
  (let args = (map args -> `(x = y)
                [(uniq) x y])
    `(let ,@(map args -> [u x]
              `(u = x))
       (do ,@(map args -> [_ x y]
               `(set! x y))
           (ensure-cleanup
             body
             (do ,@(map args -> [u x]
                     `(set! x u))))))))

# Taken from Clojure's -> operator
# http://clojuredocs.org/clojure_core/clojure.core/-%3E
($mac << -> x @args
  (foldl x args -> x y
    (if (list? y)
      (let [y @rest] = y
        `(y x ,@rest))
      `(y x))))

# Taken from Clojure's ->> operator
# http://clojuredocs.org/clojure_core/clojure.core/-%3E%3E
($mac >> -> x @args
  (foldl x args -> x y
    (if (list? y)
      `(,@y x)
      `(y x))))

($mac alias -> @args
  `(do ,@(map args -> `(x = y)
           `(do ($var x)
                ($get! x -> `y)))))

($mac loop -> @args body
  (w/sym recur
    `(w/new-scope
       (def recur -> ,@(map args -> `(l = r) l)
         body)
       (recur ,@(map args -> `(l = r) r)))))

($mac if-has? -> `(n = (get o k)) yes no
  (w/uniq u v
    `(place o k -> u v
       (if v
         (let n = u
           yes)
         no)))
  #|(w/uniq u
    `(let u = k
       (if (has? o u)
         (let n = (get o u)
           yes)
         no)))|#
)

# TODO
($mac case -> x @args last
  (w/uniq u
    `(let u = x
       ,(foldr args last -> x y
          `(if-let x = u
             y)))))


($module "nulan:lib/buffer"
  (export:keys value loc)

  (export:def merge -> (obj value = x
                            loc   = loc1)
                       (obj value = y
                            loc   = loc2)
    (obj value = "@x@y"
         loc   = { source = (or loc1.source
                                loc2.source)
                   start  = loc1.start
                   end    = loc2.end })))


(if (match? x `n = v)
      (let `n = v x
        ...)
    (if (match? x n)
          (let n = x
            ...)
        (error "foo")))

if (type.isArray(x) && array.len(x) === 3) {

}


($mac match -> top @args
  (w/complex top
    (loop [x y @args] = args
      `(if (match? top x)
         (let x = top
           y)
         ,(if (len? args)
            (recur args)
            `(error "no patterns matched"))))))

($mac match -> top @args
  (w/complex top
    (foldr (pair args) `(error "no patterns matched") -> [n x] y
      `(if (match? top n)
         (let n = top
           x)
         y))))

($mac use -> @args
  `(do ,@(map args -> x
           (match x
             `n = v
               `(alias n = (sym->external v))
             n
               `(alias ,(external->var n) = (sym->external n))))))
