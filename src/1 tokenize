(keys %type %args)

(var rules = {})

(def delimiter? -> s
  (get rules s "delimiter"))



($import { string->loc merge value loc Error } = "nulan:lib/loc"
         { test                              } = "nulan:re")

(export:keys type args)

(var rules = {})

($mac if-rule-has? -> `(n = (get o k)) then else
  (w/uniq u
    `(if-has? u = (get rules (get o value))
       (if-has? n = (get u k)
         then
         else)
       else)))

#|($mac if-rule -> `(n = v) yes no
  (w/uniq u
    `(let { value = u } = v
       (if-let { u } = rules
         (if-let n = u
           yes
           no)
         no))))|#

($mac literal -> @args
  (w/uniq x y
    `(do ,@(map args -> s
             `(def s -> x y
                (obj type = ,"@s"
                     args = [x]
                     loc  = y))))))

(export:literal symbol string number)

(def delimiter? -> x
  (if-rule-has? x = x.delimiter
    x
    false))

(def atom -> (obj value loc)
  (if (test value "^[0-9]+$")
    (number (->num value) loc)
    (symbol value loc)))

(def tokenize-atom -> token a
  (if (delimiter? token)
    (cons (atom token)
          (next a))
    (let [x a] = (partition-while a -> x
                   (not:delimiter? x))
      (cons (atom:merge x)
            (next a)))))

(def next -> a
  (if (nil? a)
    nil
    (let (cons token a) = a
      (if-rule-has? f = token.tokenize
        (f token a)
        (tokenize-atom token a)))))

(export:def tokenize -> s filename
  (next:buffer s filename))


(def whitespace -> token a
  (next a))

(def tokenize-string -> end
  (-> token a
    (cons token
      (loop a = a
        (if (nil? a)
          (throw:new Error token "missing ending @end")
          (let (cons x a) = a
            (let s = (get x value)
              (if (is s end)
                    (cons s (next a))

                  (is s "@")
                    (recur a)

                  (is s "\n")
                    (recur a)

                  (let [x a] = (partition-while a -> (obj value = x)
                                 (isnt x end "@" "\n"))
                    (let (obj value loc) = (merge x)
                      (cons (string value loc)
                            (recur a))))))))))))



(def op -> s x a
  (obj type = s
       args = a
       loc  = x))


(var symbols boxes)

(defcase find-symbols
  => (obj type = "symbol"
          args = [x])
     (set! (get symbols x) = true)

  => (obj args)
     (each args find-symbols))

(defcase find-boxes
  => (obj type = "function"
          args)

  => (obj type = "var"
          args)

  => (obj args)
     (each args find-boxes))

(defcase replace
  => (var x = (obj type = "box"
                   loc  = x
                   id))
     (if-has? box = (get boxes id)
       (proxy box loc = x)
       (error "@x used before assignment"))

  => (var x = (obj args))
     (proxy x args = (map args replace))

  => x
     x
)

(w/var symbols = {}
       boxes   = {}
  (find-symbols x)
  (replace x))

(defcase map
  => []        _
     []
  => [x @args] f
     [(f x) @(map args f)])

(defcase map
  []        _ => []
  [x @args] f => [(f x) @(map args f)])

(def map -> @a
  (let [b c] = a
    (is (and (list? b)
             (is (len b) 0))
          (let [] = b
               f  = c
            [])
        (and (list? b)
             (>= (len b) 1))
          (let [x @args] = b
               f         = c
            [(f x) @(map args f)])
        (error "no matching case for map"))))

function map(a, f) {
  if (isList(a)) {
    var b = len(a)
    if (b === 0) {
      return []
    } else if (b >= 1) {
      var x    = b[0]
        , args = [].slice.call(b, 1)
      return [f(x)].concat(map(args, f))
    }
  }
  throw new Error("no matching case for map")
}


(defcase foo
  [x] []  => [x ()]
  []  [y] => [() y]
  [x] [y] => [x  y])

function foo(a, b) {
  if (isList(a)) {
    var c = len(a)
    if (c === 0) {
      if (isList(b) && len(b) === 1) {
        var y = b[0]
        return [void 0, y]
      }
    } else if (c === 1) {
      if (isList(b)) {
        var d = len(b)
        if (d === 0) {
          var x = a[0]
          return [x, void 0]
        } else if (d === 1) {
          var x = a[0]
            , y = b[0]
          return [x, y]
        }
      }
    }
  }
  throw new Error("no matching case for foo")
}
