(TYPE Code
  # Literals
  (*wildcard Source)
  (*integer Integer Source)
  (*number Number Source)
  (*text Text Source)

  # Symbols
  (*symbol Text Source)
  (*data Text Source)
  (*protocol Text Source)
  (*type Text Source)
  (*rewrite-rule Text Source)
  (*unique-symbol Count Source)

  # Boxes
  (*box { id :: Count
          macro :: (Maybe (-> Code (Task (Result Code Compile-Error))))
          source :: Source })

  # Multi-ary
  (*list (List Code) Source)
  (*call (List Code) Source)
  (*record (List Code) Source)
  (*lambda (List Code) Code Source)

  # Binary
  (*assign Code Code Source)
  (*type Code Code Source)
  (*colon Code Code Source)

  # Unary
  (*bar Code Source)
  (*quote Code Source)
  (*unquote Code Source)
  (*splice Code Source))


(PROVIDE ($equal? Code)
  (FUNCTION-UNION equal? :: (-> Code Code Boolean)
    [ [ (*wildcard _) (*wildcard _) ] ]
    : *true

    [ [ (*integer a _) (*integer b _) ]
      [ (*number a _) (*number b _) ]
      [ (*text a _) (*text b _) ]
      [ (*symbol a _) (*symbol b _) ]
      [ (*data a _) (*data b _) ]
      [ (*protocol a _) (*protocol b _) ]
      [ (*type a _) (*type b _) ]
      [ (*rewrite-rule a _) (*rewrite-rule b _) ]
      [ (*unique-symbol a _) (*unique-symbol b _) ]
      [ (*list a _) (*list b _) ]
      [ (*call a _) (*call b _) ]
      [ (*record a _) (*record b _) ]
      [ (*bar a _) (*bar b _) ]
      [ (*quote a _) (*quote b _) ]
      [ (*unquote a _) (*unquote b _) ]
      [ (*splice a _) (*splice b _) ]
      [ (*box { a <= id }) (*box { b <= id }) ] ]
    : (equal? a b)

    [ [ (*lambda a1 a2 _) (*lambda b1 b2 _) ]
      [ (*assign a1 a2 _) (*assign b1 b2 _) ]
      [ (*type a1 a2 _) (*type b1 b2 _) ]
      [ (*colon a1 a2 _) (*colon b1 b2 _) ] ]
    : (AND
        (equal? a1 b1)
        (equal? a2 b2))))
