$mac prn -> @args
  'console.log ,@args

$mac def -> n v
  '| var n
   | n <= v

$mac str -> @args
  '(+) "" ,@args

# TODO: `call 1 2 3 4 5` doesn't work
$mac call -> x y @args
  'x[y].call ,@args

$mac call-own -> x y @args
  'x[y] ,@args

$mac in -> @args
  w/var r = {}
    | args.reduce -> x y
        | r.push {x y}
        | x
    | '(||) ,@(r.map -> x '(==) ,@x)

$mac (~=) -> @args
  if args.length == 2
    '& "!==" ,args.0 ,args.1
    '~ ((==) ,@args)

$mac for -> init test incr body
  '| init
   | while test
       | body
       | incr

$mac w/uniq -> @args body
  'w/var ,@(args.map -> x 'x = uniq;)
     body

$mac w/var! -> {('=) x y} body
  w/uniq u
    'w/var u = x
       | x <= y
       | finally body
           x <= u

$mac w/complex -> x body
  w/uniq u v
    'if: Array.isArray x
       w/uniq u v
         w/var v = x
               x = u
           'w/var u = v
              # TODO: a little hacky, but it works; figure out a better way?
              ,(',) body
       body




#|
(mac complex (x body)
  (w/uniq (u v)
    `(if (isa ,x 'sym)
         ,body
         (w/uniq (,u ,v)
           (withs (,v ,x
                   ,x ,u)
              `(let ,,u ,,v
                 ,,body))))))

mac uniqs -> @args body
  '| var ,@(args.map -> x 'x = uniq;)
   | body

mac vars -> @args
  '(|) ,@(args.map -> x 'var x)

mac w/vars -> @args
  args.reduceRight -> x y
    'w/var y x

mac w/def -> x '(| f @body)
  'w/var x
     (|) (x <= f) ,@body

w/def foo
  | -> a (a + 2)
      foo
  | foobar

w/def foo ((|) bar 1 2 3)

$eval
  w/var y = {1 2 3}
    w/complex y y

w/uniq u v
  w/var v = y
        y = u
    'w/var u = v
      y
|#

#|
[ foo -> 10
| bar -> 20
| qux -> 30 ]

| foo | bar | qux


let u {}
  | foo 1
  | bar 5
  | qux 10


|||| foo | bar ||| qux


-> a a | 5


{ -> a b c | -> a b c | -> a b c }


if qux corge
  | a
  | b
  if foo bar
    | d
    | e
    if nou yesno
      | f
      | g
      h
|#
