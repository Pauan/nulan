###  Core
$eval
  | var $run = make-macro -> {_ x}
                 &compile '$eval
                             | x
                             | ()
  | ()

# TODO partial scope, if it isn't too hard to add in
$run
  var w/var = make-macro -> {_ @args body}
                &compile 'w/new-scope
                            | var ,@args
                            | body

$run
  var make-macro-wrapper =
    # TODO
    -> f
      make-macro -> {_ @args}
        &compile (f @args)

$run
  var $mac = make-macro -> {_ n f}
               &compile '$run
                           | var n
                           | n <= make-macro-wrapper f

#|
$run
  w/var u    = make-uniq;
        args = make-uniq;
    console.log u args

$run
  var $mac = make-macro -> {_ boxes f}
               w/var u    = make-uniq;
                     args = make-uniq;
                 &compile '$run
                             | var boxes
                             | boxes <= w/var u = f
                                          make-macro -> {_ @args}
                                            &compile (u @args)
|#

###  Macro utilities
$mac w/uniq -> @args body
  'w/var ,@(args.map -> x 'x = make-uniq;)
     body

$mac w/complex -> x body
  w/uniq u v
    'if: Array.isArray x
       w/uniq u v
         w/var v = x
               x = u
           'w/var u = v
              ,body
       w/new-scope
         body


###  Variable binding
#$mac w/include -> @args body

$mac defs -> @body
  '| var ,@(body.map -> {x} x)
   | ,@(body.map -> {x y} 'x <= y)

#|
# TODO: define def in terms of defs?
$mac def -> n v
  '| var n
   | n <= v|#

$mac def -> n v
  'defs: n v

# Dynamic variable binding. Usage:
#   var foo = 5
#   w/var! foo = 10
#     foo
#   foo
$mac w/var! -> {('=) x y} body
  w/uniq u
    'w/var u = x
       | x <= y
         # TODO: should finally use w/new-scope?
       | finally body
           x <= u

$mac w/dict! -> args body
  'w/var! args = Object.create args
     body


###  Miscellaneous
$mac prn -> @args
  'console.log ,@args

#|
$mac str -> @args
  '(+) "" ,@args
|#

#|
$mac call -> x y @args
  'x[y].call ,@args

$mac call-own -> x y @args
  'x[y] ,@args
|#

$mac |= -> @args
  w/var r = {}
    | args.reduce -> x y
        | r.push {x y}
        | x
    | '|| ,@(r.map -> x '== ,@x)

$mac ~= -> @args
     # TODO
  if (== args.length 2)
    # TODO
    '& "!==" ,args.0 ,args.1
       # TODO
    '~ (== ,@args)


###  Loops
$mac for -> init test incr body
  'w/new-scope
     | init
     | while test
         | body
         | incr

$mac w/each -> {('=) x y} body
  w/uniq i len
    w/complex y
      'w/var len = y.length
         for (var i = 0) (i ~= len) (++ i)
           w/var x = y[i]
             body

$mac w/each-rev -> {('=) x y} body
  w/uniq i
    w/complex y
      'w/var i = y.length
         while i
           w/var x = y[-- i]
             body


###  Syntax
$mac $syntax-protect -> body
  '$run
     w/dict! syntax-rules
       body

$mac $syntax-rule -> s o
  '$run
     syntax-rules[,(str s)] <= o

$mac $syntax-helper -> n f
  w/uniq s i o u
    '$mac n -> s (i = 0) (o = '[])
       '$run
          # TODO: make it work with w/complex somehow?
          w/var u = o
            | u.priority <= i
            | u.parse <= f
            | $syntax-rule s u

#| TODO: Fix this
| [].foo <= 10
| [].bar <= 20
|#

$run
  | def syntax-infix -> {@l x} s {y @r}
      ',@l (s x y) ,@r
  | $syntax-helper $syntax-infix syntax-infix

$run
  | def syntax-unary -> l s {y @r}
      ',@l (s y) ,@r
  | $syntax-helper $syntax-unary syntax-unary


$syntax-unary ~  90

$syntax-infix *  80
$syntax-infix /  80

$syntax-infix +  70
$syntax-infix -  70

$syntax-infix <  60
$syntax-infix =< 60
$syntax-infix >  60
$syntax-infix >= 60

$syntax-infix == 50
$syntax-infix |= 50
$syntax-infix ~= 50

$syntax-infix && 40

$syntax-infix || 30



#|
(mac complex (x body)
  (w/uniq (u v)
    `(if (isa ,x 'sym)
         ,body
         (w/uniq (,u ,v)
           (withs (,v ,x
                   ,x ,u)
              `(let ,,u ,,v
                 ,,body))))))

mac uniqs -> @args body
  '| var ,@(args.map -> x 'x = uniq;)
   | body

mac vars -> @args
  '(|) ,@(args.map -> x 'var x)

mac w/vars -> @args
  args.reduceRight -> x y
    'w/var y x

mac w/def -> x '(| f @body)
  'w/var x
     (|) (x <= f) ,@body

w/def foo
  | -> a (a + 2)
      foo
  | foobar

w/def foo ((|) bar 1 2 3)

$run
  w/var y = {1 2 3}
    w/complex y y

w/uniq u v
  w/var v = y
        y = u
    'w/var u = v
      y
|#

#|
[ foo -> 10
| bar -> 20
| qux -> 30 ]

| foo | bar | qux


let u {}
  | foo 1
  | bar 5
  | qux 10


|||| foo | bar ||| qux


-> a a | 5


{ -> a b c | -> a b c | -> a b c }


foo bar @qux

'foo bar @qux

''foo bar @qux

'''foo bar @qux


'foo ,bar ,@qux

''foo ,bar ,@qux

''foo ,,bar ,,@qux


if qux corge
  | a
  | b
  if foo bar
    | d
    | e
    if nou yesno
      | f
      | g
      h

if qux corge
  | a
  | b
  foo bar
  | d
  | e
  nou yesno
  | f
  | g
  h
|#
